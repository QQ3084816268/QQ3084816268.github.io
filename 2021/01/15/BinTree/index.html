<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题： 哪一个是根节点？ 哪些是叶子">
<meta property="og:type" content="article">
<meta property="og:title" content="BinTree">
<meta property="og:url" content="http://example.com/2021/01/15/BinTree/index.html">
<meta property="og:site_name" content="Axuan&#39;Blog">
<meta property="og:description" content="1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题： 哪一个是根节点？ 哪些是叶子">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://axuannote-1304271763.cos.ap-nanjing.myqcloud.com/2020/12/20201229132242350.png">
<meta property="og:image" content="https://axuannote-1304271763.cos.ap-nanjing.myqcloud.com/2020/12/20201229135047759.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210102144625660.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210103010119208.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210102162127457.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210106170612230.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210107025758753.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210107025958120.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210107035541962.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210108023455276.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210109021240576.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210109032847991.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210110063417832.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210110064026853.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210110085219193.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210110094541646.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210110095929776.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210111021509034.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210111032527707.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210111040800678.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210111044141943.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210112032259166.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210112033211206.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210112035709735.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210112040119159.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210113023421177.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210113042724457.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210113042743315.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210113043811346.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210114023247167.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210114023606655.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210114033511255.png">
<meta property="og:image" content="c:/Users/Axuan/AppData/Roaming/Typora/typora-user-images/image-20210115114909341.png">
<meta property="article:published_time" content="2021-01-15T14:46:34.000Z">
<meta property="article:modified_time" content="2021-01-15T19:16:59.030Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="BinTree">
<meta property="article:tag" content="Tree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://axuannote-1304271763.cos.ap-nanjing.myqcloud.com/2020/12/20201229132242350.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>BinTree</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/01/15/my-first-blog/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/15/hello-world/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/01/15/BinTree/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/01/15/BinTree/&text=BinTree"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/01/15/BinTree/&is_video=false&description=BinTree"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=BinTree&body=Check out this article: http://example.com/2021/01/15/BinTree/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/01/15/BinTree/&name=BinTree&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/01/15/BinTree/&t=BinTree"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%A3%B5%E6%A0%91%E8%BE%B9%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%BA-lt-I-M-gt-lt-I-N-gt-lt-E-I-gt-lt-B-E-gt-lt-B-D-gt-lt-A-B-gt-lt-G-J-gt-lt-G-K-gt-lt-C-G-gt-lt-C-F-gt-lt-H-L-gt-lt-C-H-gt-lt-A-C-gt-%EF%BC%8C%E8%AF%B7%E7%94%BB%E5%87%BA%E8%BF%99%E6%A3%B5%E6%A0%91%EF%BC%8C%E5%B9%B6%E5%9B%9E%E7%AD%94%E4%B8%8B%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E6%A3%B5%E5%BA%A6%E4%B8%BA2%E7%9A%84%E6%A0%91%E5%92%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">2、一棵度为2的树和一棵二叉树有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%B8%80%E6%A3%B5%E6%B7%B1%E5%BA%A6%E4%B8%BAH%E7%9A%84%E6%BB%A1k%E5%8F%89%E6%A0%91%E6%9C%89%E5%A6%82%E4%B8%8B%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">4、一棵深度为H的满k叉树有如下性质：</span></a>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        BinTree
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">John Doe</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-15T14:46:34.000Z" itemprop="datePublished">2021-01-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Tree/">Tree</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/BinTree/" rel="tag">BinTree</a>, <a class="tag-link-link" href="/tags/Tree/" rel="tag">Tree</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h4 id="1、已知一棵树边的结合为-lt-I-M-gt-lt-I-N-gt-lt-E-I-gt-lt-B-E-gt-lt-B-D-gt-lt-A-B-gt-lt-G-J-gt-lt-G-K-gt-lt-C-G-gt-lt-C-F-gt-lt-H-L-gt-lt-C-H-gt-lt-A-C-gt-，请画出这棵树，并回答下列问题："><a href="#1、已知一棵树边的结合为-lt-I-M-gt-lt-I-N-gt-lt-E-I-gt-lt-B-E-gt-lt-B-D-gt-lt-A-B-gt-lt-G-J-gt-lt-G-K-gt-lt-C-G-gt-lt-C-F-gt-lt-H-L-gt-lt-C-H-gt-lt-A-C-gt-，请画出这棵树，并回答下列问题：" class="headerlink" title="1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题："></a>1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题：</h4><ol>
<li>哪一个是根节点？</li>
<li>哪些是叶子结点？</li>
<li>哪个是结点G的双亲？</li>
<li>哪些是结点G的祖先？</li>
<li>哪些是结点G的孩子？</li>
<li>哪些是结点E的子孙？</li>
<li>哪些是结点E的兄弟？哪些是结点F的兄弟？</li>
<li>结点B和N的层次号分别是什么？</li>
<li>树的深度是多少</li>
<li>以结点C为根的子树的深度是多少？</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://axuannote-1304271763.cos.ap-nanjing.myqcloud.com/2020/12/20201229132242350.png" alt="img"></p>
<h3 id="2、一棵度为2的树和一棵二叉树有何区别？"><a href="#2、一棵度为2的树和一棵二叉树有何区别？" class="headerlink" title="2、一棵度为2的树和一棵二叉树有何区别？"></a>2、一棵度为2的树和一棵二叉树有何区别？</h3><ul>
<li>度不同<ul>
<li>度为2的树要求每个结点最多只能由两颗子树，并且至少由一个结点有两棵子树，二叉树的要求是度不超过2，结点最多有两个分支，可能为1或者0</li>
<li>在任意一棵二叉树中，度为0的结点(即叶子结点)总是比度为2的结点多一个</li>
</ul>
</li>
<li>分支不同<ul>
<li>度为2的树有两个分支，但分支没有左右之分</li>
<li>一棵二叉树也有两个分支，但有左右之分，左右子树的次数不能随意颠倒</li>
</ul>
</li>
<li>次序不同<ul>
<li>度为2的树从形式上看与二叉树很相似，但是其子树是无序的，而二叉树是有序的，即，在一般树中，若某个结点只有一个孩子，就无需区分其左右次序，而在二叉树中即使是一个孩子也有左右之分</li>
</ul>
</li>
</ul>
<p>3、试分别画出具有3个结点的树和3个结点的二叉树的所有不同形态</p>
<p><img src="https://axuannote-1304271763.cos.ap-nanjing.myqcloud.com/2020/12/20201229135047759.png" alt="img"></p>
<h3 id="4、一棵深度为H的满k叉树有如下性质："><a href="#4、一棵深度为H的满k叉树有如下性质：" class="headerlink" title="4、一棵深度为H的满k叉树有如下性质："></a>4、一棵深度为H的满k叉树有如下性质：</h3><ul>
<li><p>第H层上的结点都是叶子结点，其余各层上每个结点都有k棵非空子树</p>
</li>
<li><p>如果按层次顺序从1开始对全部结点编号，问：</p>
<ol>
<li>各层的结点数目是多少？</li>
<li>编号为p的结点的父结点(若存在)的编号是多少？</li>
<li>编号为p的结点的第i个儿子结点(若存在)的编号是多少？</li>
<li>编号为p的结点有右兄弟的条件是什么？其右兄弟编号是多少？</li>
</ol>
</li>
</ul>
<p>33、假设用两个一维数组L[n+1]和R[n+1]作为n个结点的二叉树存储结构，L[i]和R[i]分别指示结点i(i=1,2,…,n)的左孩子和右孩子，0表示空，试写一算法判别结点u是否为结点v的双亲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">T6_33</span><span class="params">(BinTree L, BinTree R, <span class="keyword">int</span> n, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//标记</span></span><br><span class="line">	<span class="keyword">if</span> (!v) <span class="keyword">return</span> FALSE;<span class="comment">//结点为空</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (L[v] == u)  <span class="keyword">return</span> TRUE;<span class="comment">//找到u结点，位于v的左子树</span></span><br><span class="line">	<span class="keyword">else</span> flag += T6_33(L, R, n, u, L[v]);<span class="comment">//递归传入左子树判断</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (R[v] == u) <span class="keyword">return</span> TRUE;<span class="comment">//找到u结点，位于v的右子树</span></span><br><span class="line">	<span class="keyword">else</span> flag += T6_33(L, R, n, u, L[v]);<span class="comment">//递归传入右子树判断</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span> TRUE;<span class="comment">//若标记为true 则返回true</span></span><br><span class="line">	<span class="keyword">return</span> FALSE;<span class="comment">//否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34、假定用两个一维数组L[1..n]和R[1..n]作为有n个结点的二叉树的存储结构， L[i]和R[i]分别指示结点i的左孩子和右孩子，0表示空。试写一个算法,先由L和R建立一维数组T[1..n]，使T中第i(i=1,2,…,n)个分量指示结点i的双亲，然后判别结点u是否为结点v的子孙。</p>
<p>这道题初次看的时候有点懵，但是我们一步一步来，先看对应的存储结构如下所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210102144625660.png"></p>
<p>现在直观多了，从上图我们可以得知：</p>
<ul>
<li>T[ L[ i ] ] = i</li>
<li>T[ R[ i ] ] = i<ul>
<li>举个例子，当 i == 1 时候</li>
<li><strong>T[ L[ 1 ] ] == T[2] = 1</strong> </li>
<li><strong>T[ R[ 1 ] ] == T[ 3 ] = 1</strong></li>
</ul>
</li>
</ul>
<p>这样我们就可以写出创建 T 数组的 循环程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BinTree[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">T6_34</span><span class="params">(BinTree L, BinTree R, BinTree T, <span class="keyword">int</span> n, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断结点u是否为结点v的子孙</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过L和R创建T数组(双亲数组)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; L[i] || R[i]; i++)<span class="comment">//L[i]&amp;&amp;R[i] :从编号为1 的根结点开始，知道最后一个叶子结点，左右子树均为空时</span></span><br><span class="line">	&#123;</span><br><span class="line">		T[L[i]] = i;</span><br><span class="line">		T[R[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, T[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &gt;= u; i = T[i])<span class="comment">//从给定的v结点开始往双亲查找，不断迭代双亲，若等于则直接返回true</span></span><br><span class="line">		<span class="keyword">if</span> (i == u) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题难点就在比较绕，需要结合图像进行分析。</p>
<p>35、假设二叉树中左分支的标号为“0”，右分支的标号为“1”，并对二叉树增设一个头结点，令根结点为其右孩子，则从头结点到树中任一结点所经分支的序列为一个二进制序列，可认作是某个十进制数的二进制表示，例如，右图所示二叉树中，和结点A对应的二进制序列为“110”，即十进制整数6的二进制表示，已知一棵非空二叉树以顺序存储结构表示，试写以尽可能简单的算法，求出与在树的顺序存储结构中下标值为i的结点对应的十进制整数。</p>
<p>思路：</p>
<ul>
<li>从题意可知，我们需要从给定的结点出发查找双亲，并且判断上一结点是左孩子为1，右孩子为0，进行一个string拼接操作</li>
<li>最好的存储结构是【孩子双亲顺序存储结构】，如下所示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINTREE_MAX 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> rchild;</span><br><span class="line">	<span class="keyword">int</span> lchild;</span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">&#125;BinTree[BINTREE_MAX];</span><br></pre></td></tr></table></figure>
<p>如下二叉树所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210103010119208.png" alt="image-20210103010119208"></p>
<p>完整算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">T6_35</span><span class="params">(BinTree* T, <span class="keyword">int</span> i,<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; size) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> pre = <span class="number">0</span>; <span class="keyword">int</span> start = BINTREE_MAX - <span class="number">1</span>; <span class="keyword">int</span> n = BINTREE_MAX - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> str[BINTREE_MAX];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &gt;= <span class="number">1</span>; p=T[p].parent) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre &amp;&amp; T[p].lchild == pre) <span class="comment">//添加0;</span></span><br><span class="line">			str[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pre &amp;&amp; T[p].rchild == pre) <span class="comment">//添加1</span></span><br><span class="line">			str[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		pre = p;</span><br><span class="line">		start--;</span><br><span class="line">	&#125;</span><br><span class="line">	str[start] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//虚拟头结点编号增1.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换为十进制</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;=n; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[j] == <span class="string">&#x27;1&#x27;</span>) num += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt; n)num = num *= <span class="number">2</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210102162127457.png" alt="image-20210102162127457"></p>
<p>36、若已知两棵二叉树B1和B2皆为空，或者皆不空且B1的左、右子树和B2的左、右子树分别相似，则称二叉树B1和B2相似，试编写算法，判别给定两棵二叉树是否相似。</p>
<p>思路：有了广义表那一章的折磨，这道题应该很容易，就是递归判断罢了，在题目中已经给出出口了，<strong>当两棵树均为空的时候，返回true，若不为空，则判断其左右子树是否为空，当有一个为空时，返回false。</strong></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BinTreeNode &#123;</span></span><br><span class="line"><span class="comment">	int data;</span></span><br><span class="line"><span class="comment">	struct BinTreeNode* lchild;</span></span><br><span class="line"><span class="comment">	struct BinTreeNode* rchild;</span></span><br><span class="line"><span class="comment">&#125;*BinTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SimBinTree</span><span class="params">(BinTree T, BinTree T1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T &amp;&amp; !T1) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(T&amp;&amp;T1)&#123;</span><br><span class="line">		<span class="keyword">if</span> (SimBinTree(T-&gt;lchild, T1-&gt;lchild)) &#123;</span><br><span class="line">			<span class="keyword">return</span> SimBinTree(T-&gt;rchild, T1-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>37、试利用栈的基本操作写出先序遍历的非递归形式算法</p>
<p>这题不多讲，在之前笔记中有过：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderT0raversal</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	BinTree p = T;</span><br><span class="line">	BinStack S;</span><br><span class="line">	InitBinStack(&amp;S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p || S.top &gt; S.base) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			Visit(p);<span class="comment">//访问根</span></span><br><span class="line">			Push(&amp;S, p);</span><br><span class="line">			p = p-&gt;lchild;<span class="comment">//访问左子树</span></span><br><span class="line">		&#125;</span><br><span class="line">		Pop(&amp;S, &amp;p);</span><br><span class="line">		p = p-&gt;rchild;<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>38、写出后续遍历的非递归算法</p>
<p>将 <strong>左右根</strong> 转换为 <strong>根右左</strong> 然后 reversal 即可。算法如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraversal</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	BinStack S, S1;</span><br><span class="line">	InitBinStack(&amp;S);</span><br><span class="line">	InitBinStack(&amp;S1);</span><br><span class="line">	BinTree p = T;</span><br><span class="line">	<span class="keyword">while</span> (p || S.top &gt; S.base) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			Push(&amp;S, p);</span><br><span class="line">			Push(&amp;S1, p);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		Pop(&amp;S, &amp;p);</span><br><span class="line">		p = p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	S1.top--;</span><br><span class="line">	<span class="keyword">while</span> (S1.base &lt;= S1.top) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (*(S1.top))-&gt;data);</span><br><span class="line">		S1.top--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>39、假设在二叉链表的结点中增设两个域：双亲域(parent)以指示其双亲结点：标志域(mark取值0..2)以去区分在遍历过程中到达该结点时应继续向左或向右或访问该结点，试以此存储结构编写不用栈进行后序遍历的地推算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct BinTreeNode &#123;</span></span><br><span class="line"><span class="comment">	int data;</span></span><br><span class="line"><span class="comment">	struct BinTreeNode* lchild;</span></span><br><span class="line"><span class="comment">	struct BinTreeNode* rchild;</span></span><br><span class="line"><span class="comment">	struct BinTreeNode* parent;</span></span><br><span class="line"><span class="comment">	int mark;</span></span><br><span class="line"><span class="comment">&#125;*BinTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraversal_NSr</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	BinTree p = T;</span><br><span class="line">	T-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;mark == <span class="number">0</span>) &#123;<span class="comment">//访问左子树</span></span><br><span class="line">			p-&gt;mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">				p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;mark == <span class="number">1</span>) &#123;</span><br><span class="line">			p-&gt;mark = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Visit(p);</span><br><span class="line">			p-&gt;mark = <span class="number">0</span>;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题我一直在访问左子树和右子树的标记哪儿琢磨，没想到看到答案后程序那么简单，我们需要记住以下几个点：</p>
<ul>
<li>在后序遍历中，因为顺序是 <strong>左右根</strong> 则我们需要在先将左右子树全部遍历完之后最后访问根结点</li>
<li>从左子树返回到根，标记为1</li>
<li>若标记为1，则访问其右子树</li>
<li>从右子树返回到根，标记为2</li>
<li>若结点标记为2，则访问该结点(恢复0)是为了进行下一次遍历,访问其双亲</li>
</ul>
<p>40、若在二叉链表的结点中只增设一个双亲域以指示其双亲结点，则在遍历过程中能否不设栈？试以此存储结构编写不设栈进行中序遍历的递推形式的算法</p>
<p>思路：中序遍历的顺序是 <strong>左根右</strong> 根据这个顺序 先遍历其左子树，直到左子树为空的时候 <strong>访问其根结点</strong> 然后遍历其右子树即可。算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraversal_NSr</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	BinTree p = T;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;lchild) p = p-&gt;lchild;<span class="comment">//向左走到尽头</span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild) &#123;<span class="comment">//寻找中序后继：当有右子树时</span></span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;lchild)p = p-&gt;lchild;<span class="comment">//后继就是在右子树中向左走到尽头</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;parent-&gt;lchild == p) p = p-&gt;parent;<span class="comment">//当自己是双亲的左孩子时，后继就是双亲</span></span><br><span class="line">		<span class="comment">//难点</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;parent &amp;&amp; p-&gt;parent-&gt;rchild == p)p = p-&gt;parent;</span><br><span class="line">			p = p-&gt;parent;</span><br><span class="line">		&#125;<span class="comment">//当自己是双亲的右孩子时，后继就是向上返回直到遇到自己是在其左子树中的祖先</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>41、编写递归算法，在二叉树中求位于先序序列中第k个位置的结点的值</p>
<p>思路：这题我们需要维护一个指针变量，指针内存储的值是递归的次数，然后按先序遍历访问二叉树，当递归次数为k的时候，就输出其值即可，<strong>先沿着左子树去查找，若左子树未找到，则访问其右子树，若左子树找到了，则直接返回</strong> 代码如下所示：、</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find_PreOredrBinTree</span><span class="params">(BinTree T, <span class="keyword">int</span> k,<span class="keyword">int</span> *n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		(*n)++;</span><br><span class="line">		<span class="keyword">if</span> (*n == k) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (Find_PreOredrBinTree(T-&gt;lchild, k, n)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> Find_PreOredrBinTree(T-&gt;rchild, k, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>42、编写递归算法，计算二叉树中叶子结点的数目</p>
<p>思路：按任意次序递归访问二叉树，当当前结点的左右子树都为空的情况下，则计数即可。代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafNodeNumber</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> LeafNodeNumber(T-&gt;lchild) + LeafNodeNumber(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>43、编写算法，将二叉树中所有结点的左右子树互换</p>
<p>思路：交换左右子树即可，代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SwapBinTreeNode</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		BinTree temp = T-&gt;lchild;</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild;</span><br><span class="line">		T-&gt;rchild = temp;</span><br><span class="line">		SwapBinTreeNode(T-&gt;lchild);</span><br><span class="line">		SwapBinTreeNode(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44、编写递归算法，求二叉树中元素值为x的结点为根的子树的深度</p>
<p>用一个标记，当遍历到x结点时候，开始计算深度即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xNode_BinTreeDepth</span><span class="params">(BinTree T, <span class="keyword">int</span> flag, ElemType x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m; <span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> (T-&gt;data == x) flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;<span class="comment">//当结点值等于x时，开始求其深度</span></span><br><span class="line">		m = xNode_BinTreeDepth(T-&gt;lchild, flag, x) + <span class="number">1</span>;</span><br><span class="line">		n = xNode_BinTreeDepth(T-&gt;rchild, flag, x) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> m;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//否则 左右子树找寻x</span></span><br><span class="line">		<span class="keyword">int</span> L = xNode_BinTreeDepth(T-&gt;lchild, flag, x);</span><br><span class="line">		<span class="keyword">int</span> R = xNode_BinTreeDepth(T-&gt;rchild, flag, x);</span><br><span class="line">		<span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> L;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>45、编写递归算法：对于二叉树中每一个元素值为x的结点，删去以它为根的子树，并释放相应空间。</p>
<p>思路：抓重点，<strong>删去结点</strong> 操作是在结点上，跟访问一个意思，我们可以根据后序遍历的思路对结点进行访问：先删去其左子树，再删去其右子树，最后删去根，代码很简单，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete_xRootBinTree</span><span class="params">(BinTree *T, <span class="keyword">int</span> flag,ElemType x)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((*T)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == (*T)-&gt;data) flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			Delete_xRootBinTree(&amp;(*T)-&gt;lchild, flag, x);</span><br><span class="line">			Delete_xRootBinTree(&amp;(*T)-&gt;rchild, flag, x);</span><br><span class="line">			<span class="built_in">free</span>((*T));</span><br><span class="line">			(*T) = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Delete_xRootBinTree(&amp;(*T)-&gt;lchild, flag, x);</span><br><span class="line">			Delete_xRootBinTree(&amp;(*T)-&gt;rchild, flag, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>46、编写复制一棵树的非递归算法</p>
<p>这题之前也有介绍过，也是访问结点，若T==NULL，则T1=NULL，否则跟着复制即可，我们可以根据递归算法写出非递归算法，采用任一一遍历次序进行结点的逐一复制，为了操作方便，我们最优考虑PreOrder进行复制，T1作为被复制树，他的所有过程均需模拟T的遍历过程，并且为其动态分配空间，代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CopyBinTree</span><span class="params">(BinTree T, BinTree* T1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) *T1 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		BinStack S, S1;</span><br><span class="line">		InitBinStack(&amp;S);</span><br><span class="line">		InitBinStack(&amp;S1);</span><br><span class="line">		</span><br><span class="line">		(*T1) = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));<span class="comment">//复制根结点</span></span><br><span class="line">		(*T1)-&gt;data = T-&gt;data;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根结点入栈</span></span><br><span class="line">		BinTree p = T;</span><br><span class="line">		BinTree p1 = (*T1);</span><br><span class="line">		Push(&amp;S, p);</span><br><span class="line">		Push(&amp;S1, p1);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (S.base &lt; S.top) &#123;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;lchild) &#123;</span><br><span class="line">				p = p-&gt;lchild;<span class="comment">//复制左子树</span></span><br><span class="line"></span><br><span class="line">				p1-&gt;lchild = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">				p1 = p1-&gt;lchild;</span><br><span class="line">				p1-&gt;data = p-&gt;data;</span><br><span class="line">				p1-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">				p1-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">				Push(&amp;S, p);<span class="comment">//结点入栈</span></span><br><span class="line">				Push(&amp;S1, p1);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//弹出栈顶元素</span></span><br><span class="line">			Pop(&amp;S, &amp;p);</span><br><span class="line">			Pop(&amp;S1, &amp;p1);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild) &#123;<span class="comment">//若存在右子树，则全部向右走一步</span></span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//复制右子树</span></span><br><span class="line">				p1-&gt;rchild = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">				p1 = p1-&gt;rchild;</span><br><span class="line"></span><br><span class="line">				p1-&gt;data = p-&gt;data;</span><br><span class="line">				p1-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">				p1-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//入栈</span></span><br><span class="line">				Push(&amp;S, p);</span><br><span class="line">				Push(&amp;S1, p1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>47、编写按层次顺序(同一层次自左至右)遍历二叉树的算法</p>
<p>思路：层次遍历需借助Queue来实现，先将根结点入队(初始状态)，在队列不为空的情况下，每次将队头元素出队，然后将其左右孩子入队即可，代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LevelTraversalBinTree</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	QueueData Q;</span><br><span class="line">	Queue QL;</span><br><span class="line">	IniTQueue(&amp;Q, &amp;QL);</span><br><span class="line"></span><br><span class="line">	BinTree p = T;</span><br><span class="line">	EnQueue(&amp;QL, p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (*(QL.front)) &#123;</span><br><span class="line">		DeQueue(&amp;QL, &amp;p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild) EnQueue(&amp;QL, p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild) EnQueue(&amp;QL, p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48、已知在二叉树中，root为根结点，p和q为二叉树中两个结点，试编写求距离他们最近的共同祖先的算法</p>
<p>思路：我们可以从根结点出发将p和q两结点的路径存入一个表中，进而去遍历两边求得最后一个相等的结点，则是他们两最近的通过祖先。代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNodes</span><span class="params">(BinTree T, BinTree* FindN, <span class="keyword">int</span> i, <span class="keyword">bool</span>* flag, BinTree N)</span> </span>&#123;<span class="comment">//求从T到p(q)的递归算法</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data == N-&gt;data) &#123;<span class="comment">//找到符合条件的结点</span></span><br><span class="line">			*flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		FindN[i] = T;<span class="comment">//当前结点存入路径</span></span><br><span class="line">		FindNodes(T-&gt;lchild, FindN, i + <span class="number">1</span>, flag, N);<span class="comment">//探寻左子树</span></span><br><span class="line">		<span class="keyword">if</span> (!(*flag)) &#123;<span class="comment">//若左子树未能找到目标结点</span></span><br><span class="line">			FindNodes(T-&gt;rchild, FindN, i + <span class="number">1</span>, flag, N);<span class="comment">//探寻右子树</span></span><br><span class="line">			<span class="comment">//FindN[i] = NULL;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinTree <span class="title">ComAnceBinTree</span><span class="params">(BinTree T, BinTree p, BinTree q)</span> </span>&#123;</span><br><span class="line">	BinTree FindQ[<span class="number">100</span>] = &#123; <span class="literal">NULL</span> &#125;;<span class="comment">//设立两个辅助数组暂存从根到p,q的路径</span></span><br><span class="line">	BinTree FindP[<span class="number">100</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//标记</span></span><br><span class="line">	FindNodes(T, FindQ, <span class="number">0</span>, &amp;flag, q);<span class="comment">//从根结点出发寻找结点Q的路径</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	FindNodes(T, FindP, <span class="number">0</span>, &amp;flag, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; FindQ[i] &amp;&amp; FindQ[i] == FindP[i]; i++);<span class="comment">//寻找两路径中最后一个相同的根结点</span></span><br><span class="line">	<span class="keyword">return</span> FindQ[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>49、编写算法判别给定二叉树是否为完全二叉树</p>
<p>思路：我们来复习下完全二叉树的定义：</p>
<p><strong>如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树</strong></p>
<ol>
<li>如果树为空，则直接返回错</li>
<li>如果树不为空：层序遍历二叉树</li>
<li>如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列；</li>
<li>如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；</li>
<li><strong>如果遇到一个结点，左孩子不为空，右孩子为空；或者(左)右孩子都为空；则该节点之后的队列中的结点都为叶子节点；该树才是完全二叉树，否则就不是完全二叉树</strong></li>
</ol>
<p>算法如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComPleteBinTree</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	BinTree p;</span><br><span class="line">	BinTree LevelArray[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">	LevelArray[<span class="number">0</span>] = T;<span class="comment">//根节点入队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">int</span> l = <span class="number">1</span>;<span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (LevelArray[i]) &#123;<span class="comment">//根据完全二叉树性质数组模拟队列</span></span><br><span class="line">		p = LevelArray[i];</span><br><span class="line">		<span class="keyword">if</span> (flag &amp;&amp; (p-&gt;lchild || p-&gt;rchild)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!p-&gt;lchild||(!p-&gt;lchild &amp;&amp; !p-&gt;rchild) || (p-&gt;lchild &amp;&amp; !p-&gt;rchild)) flag = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		LevelArray[l] = p-&gt;lchild;</span><br><span class="line">		LevelArray[r] = p-&gt;rchild;</span><br><span class="line">		i++; l += <span class="number">2</span>; r += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>50、假设以三元组(F,C,L/R)的形式输入一棵二叉树的各边(其中F表示双亲结点的表示，C表示孩子结点标识，L/R表示C为F的左孩子或右孩子)，且在输入的三元组序列中，C是按层次顺序出现的，设结点的标识是字符类型，F=’-‘ 时，C为根结点标识，若C也为’-‘,则表示输入结束，例如下图所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210106170612230.png" alt="image-20210106170612230"></p>
<p>思路：题目给出了一个便利 <strong>按层次顺序输入</strong> 这就代表我们可以起一个队列，将题目转换成按层次创建二叉树，下列我采用在原树中寻找F所代表的双亲结点，然后根据三元组的child标识对其左右子树链接即可，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRIPLESIZE_MAX 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TripleNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> F;</span><br><span class="line">	<span class="keyword">char</span> C;</span><br><span class="line">	<span class="keyword">char</span> child;</span><br><span class="line">&#125;Triple[TRIPLESIZE_MAX];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">VisitTriple</span><span class="params">(Triple T)</span> </span>&#123;<span class="comment">//观察三元组，用于检查</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c,%c,%c\n&quot;</span>, T[i].F, T[i].C, T[i].child);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (T[i].C != <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">InitTriple</span><span class="params">(Triple T)</span> </span>&#123;<span class="comment">//初始化三元组</span></span><br><span class="line">	<span class="keyword">char</span> t;<span class="comment">//消除最后一个\n，可不要</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c%c&quot;</span>, &amp;T[i].F, &amp;T[i].C, &amp;T[i].child, &amp;t);</span><br><span class="line">	&#125; <span class="keyword">while</span> (T[i].C != <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	VisitTriple(T);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">FindNode</span><span class="params">(BinTree T, BinTree* p,ElemType e)</span> </span>&#123;<span class="comment">//寻找双亲结点</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data == e)</span><br><span class="line">			*p = T;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			FindNode(T-&gt;lchild, p, e);</span><br><span class="line">			<span class="keyword">if</span> (!p) FindNode(T-&gt;rchild, p, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">CreateTripleBinTree</span><span class="params">(BinTree* T)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过三元组创建二叉链存储结构的二叉树</span></span><br><span class="line">	Triple Tr;</span><br><span class="line">	InitTriple(Tr);</span><br><span class="line">	</span><br><span class="line">	(*T) = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));<span class="comment">//创建根结点</span></span><br><span class="line">	(*T)-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;data = Tr[<span class="number">0</span>].C;</span><br><span class="line">	</span><br><span class="line">	BinTree p;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Tr[i].C != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">		FindNode(*T, &amp;p, Tr[i].F);<span class="comment">//寻找根结点.</span></span><br><span class="line">		<span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;<span class="comment">//三元组序列错误</span></span><br><span class="line">		<span class="keyword">if</span> (Tr[i].child == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">			p-&gt;lchild = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;rchild = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data = Tr[i].C;</span><br><span class="line">		p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//PreOrderTraversal(*T);检查</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>51、编写一个算法，输出以二叉树表示的算术表达式，若该表达式中含有括号，则在输出时应添上</p>
<p>思路：我们先来看两张图，思路就能很清晰了，先给出一张带括号表达式 <strong>(a+b)-(c+d)</strong> 的树型结构图</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210107025758753.png" alt="image-20210107025758753"></p>
<p>下面给出运算符优先级表</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210107025958120.png"></p>
<p><strong>正确的中缀表达式的树结构，其分支结点必定为运算符，而其叶子结点必定为操作数</strong>，为此我们可以写出根据<strong>中序遍历</strong>树结构<strong>输出其中缀表达式</strong>，算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int opIndex(char a) &#123;&#x2F;&#x2F;优先级定位</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;+&#39;) return 0;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;-&#39;) return 1;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;*&#39;) return 2;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;&#x2F;&#39;) return 3;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;(&#39;) return 4;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;)&#39;) return 5;</span><br><span class="line">&#125;</span><br><span class="line">char PriorOP(char a, char b) &#123;&#x2F;&#x2F;比较两运算符优先级</span><br><span class="line">	char Prior[6][6] &#x3D; &#123; &#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,</span><br><span class="line">						&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,</span><br><span class="line">						&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,</span><br><span class="line">						&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,</span><br><span class="line">						&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&#x3D;&#39;,</span><br><span class="line">						&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;0&#39;,&#39;&gt;&#39;, &#125;;</span><br><span class="line">	int c &#x3D; opIndex(a);</span><br><span class="line">	int d &#x3D; opIndex(b);</span><br><span class="line">	return Prior[c][d];</span><br><span class="line">&#125;</span><br><span class="line">bool Jdop(char a) &#123;&#x2F;&#x2F;判断是否为运算符</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;+&#39; || a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;*&#39; || a &#x3D;&#x3D; &#39;&#x2F;&#39; || a &#x3D;&#x3D; &#39;(&#39; || a &#x3D;&#x3D; &#39;)&#39;) return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Print_InOrderExression_Bit(BinTree T) &#123;</span><br><span class="line">&#x2F;&#x2F;根据中序遍历二叉树和运算符优先级输出其中序序列</span><br><span class="line">	if (!Jdop(T-&gt;data)) Visit(T);&#x2F;&#x2F;若是操作数，则直接输出</span><br><span class="line">	else &#123;</span><br><span class="line">		if (!T-&gt;lchild) return ERROR;&#x2F;&#x2F;非操作数的叶子结点，序列错误</span><br><span class="line">		&#x2F;&#x2F;添加括号的中序遍历.</span><br><span class="line">		if (Jdop(T-&gt;lchild-&gt;data) &amp;&amp; PriorOP(T-&gt;lchild-&gt;data, T-&gt;data) &#x3D;&#x3D; &#39;&lt;&#39;) &#123;&#x2F;&#x2F;左子树比它小，需要添加括号</span><br><span class="line">			&#x2F;&#x2F;若其左子树为运算符且其左子树优先级小于它，则需要添加括号</span><br><span class="line">			printf(&quot;(&quot;);</span><br><span class="line">			if (!Print_InOrderExression_Bit(T-&gt;lchild)) return ERROR;&#x2F;&#x2F;中序递归遍历：左根(访问)右</span><br><span class="line">			Visit(T);</span><br><span class="line">			printf(&quot;)&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;否则不添加，正常中序递归遍历</span><br><span class="line">			if (!Print_InOrderExression_Bit(T-&gt;lchild)) return ERROR;</span><br><span class="line">			Visit(T);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;右子树与左子树相同操作</span><br><span class="line">		if (!T-&gt;rchild) return ERROR;</span><br><span class="line"></span><br><span class="line">		if (Jdop(T-&gt;rchild-&gt;data) &amp;&amp; PriorOP(T-&gt;rchild-&gt;data, T-&gt;data) &#x3D;&#x3D; &#39;&lt;&#39;) &#123;</span><br><span class="line">			printf(&quot;(&quot;);</span><br><span class="line">			if (!Print_InOrderExression_Bit(T-&gt;rchild)) return ERROR;</span><br><span class="line">			printf(&quot;)&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (!Print_InOrderExression_Bit(T-&gt;rchild)) return ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码看着很复杂，但是其实思路很简单，就是中序访问罢了，而且一定记住必定是一棵完满二叉树，因为运算符为分支结点，一个运算符作用与两个操作数，测试可以根据先序创建一棵二叉树，根据其输出，如下图所示：</strong>‘</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210107035541962.png" alt="image-20210107035541962"></p>
<p>若是大佬有兴趣，可以写一个根据中序表达式创建二叉树的算法，联系我~万分感谢！</p>
<p>52、一棵二叉树繁茂度定义为各层结点数的最大值与树的高度的乘积，试写一算法，求二叉树的繁茂度</p>
<p>思路：答案就在题目里，高度就是深度，只不过高度是从下往上，而深度是从上往下，我们层次遍历二叉树，记录结点个数的最大值，然后返回其与深度的乘积即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinTreeDepth</span><span class="params">(BinTree T)</span> </span>&#123;<span class="comment">//求二叉树深度的递归算法</span></span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = BinTreeDepth(T-&gt;lchild) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = BinTreeDepth(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> m;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Level_FindMax</span><span class="params">(BinTree T,<span class="keyword">int</span> n,<span class="keyword">int</span>* LeveNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造每层次结点个数表</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		LeveNum[n]++;<span class="comment">//该层次结点个数</span></span><br><span class="line">		Level_FindMax(T-&gt;lchild, n + <span class="number">1</span>, LeveNum);</span><br><span class="line">		Level_FindMax(T-&gt;rchild, n + <span class="number">1</span>, LeveNum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LushBinTree</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = BinTreeDepth(T);</span><br><span class="line">	<span class="keyword">int</span>* LeveNum = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (dep + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dep; i++) LeveNum[i] = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	Level_FindMax(T, <span class="number">1</span>, LeveNum);<span class="comment">//构造层次结点数表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> MaxNodes = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dep; i++) </span><br><span class="line">		<span class="keyword">if</span> (MaxNodes &lt; LeveNum[i]) </span><br><span class="line">			MaxNodes = LeveNum[i];<span class="comment">//求出最大结点数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxNodes * dep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>53、试编写算法，求给定二叉树上从根结点到叶子结点的一条其路径长度等于树的深度减一的路径(即列出从根结点到该叶子结点的结点序列，若这样的路径存在多条，则输出路径终点(叶子结点)在最左边的一条)</p>
<p>思路：先序遍历+递归回溯，维护一个层次数，当这个层次数 i  等于深度 n - 1 的时候， 就找到了，先序遍历就是从左到右，所以第一条即是最左边的一条，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LeftPath</span><span class="params">(BinTree T,BinTree* Path, <span class="keyword">int</span> i, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == dep)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		Path[i] = T;</span><br><span class="line">		<span class="keyword">if</span> (LeftPath(T-&gt;lchild, Path, i + <span class="number">1</span>, dep) || LeftPath(T-&gt;rchild, Path, i + <span class="number">1</span>, dep))<span class="comment">//</span></span><br><span class="line">			<span class="comment">//左右子树DFS，左边先执行，相当于先序遍历</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">FindPath</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = BinTreeDepth(T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, dep);</span><br><span class="line">	BinTree* Path = (BinTree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTree) * (dep + <span class="number">1</span>));</span><br><span class="line">	LeftPath(T, Path, <span class="number">0</span>, dep);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dep; i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, Path[i]-&gt;data);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试用例：</strong>ABC#DEF##G##H#IJ##K###LMN#OP##Q###R#ST#U#VW##X##Y##</p>
<p>测试逻辑结构图：<img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210108023455276.png" alt="image-20210108023455276"></p>
<p>通过测试。</p>
<p>54、假设以顺序表sa表示一棵完全二叉树,sa.elem[sa.last]中存放树种各结点的数据元素，试编写算法由此顺序存储结构建立该二叉树的二叉链表。</p>
<p>思路：在完全二叉树中，孩子与其双亲结点 i 的关系如下：</p>
<ul>
<li>左孩子：2i</li>
<li>右孩子：2i+1</li>
</ul>
<p>根据上述,算法如下所示，完全二叉树按层次顺序从左到右编号，序列是连续的（中途不会出现空结点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">saNodes</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>* elem;</span><br><span class="line">	<span class="keyword">int</span> last;</span><br><span class="line">&#125;sanode;</span><br><span class="line"><span class="function">Status <span class="title">InitSa</span><span class="params">(sanode *sa)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(*sa).last);</span><br><span class="line">	<span class="keyword">if</span> (!((*sa).elem = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ((*sa).last + <span class="number">1</span>))))<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (*sa).last; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(*sa).elem[i]);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">CreateBinTree_saArray</span><span class="params">(BinTree *T)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	sanode sa;</span><br><span class="line">	<span class="keyword">if</span> (!(InitSa(&amp;sa))) <span class="keyword">return</span> ERROR;</span><br><span class="line">	BinTree* TA = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTree) * (sa.last + <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sa.last; i++) &#123;<span class="comment">//构造子树森林</span></span><br><span class="line">		TA[i] = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">		TA[i]-&gt;data = sa.elem[i];</span><br><span class="line">		TA[i]-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">		TA[i]-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">int</span> j = i / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span> * j) TA[j]-&gt;lchild = TA[i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				TA[j]-&gt;rchild = TA[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*T = TA[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>55、为二叉链表的结点增加DescNum域，试写一算法，求二叉树的每个结点的子孙数目存入其DescNum域，请给出算法的时间复杂度。</p>
<p>思路：这题我们可以使用递归实现，我初步想到的办法时间复杂度很高，想优化思路却卡壳了，后边看了下答案，才发现代码非常简单，我们先总结一下几个情况：</p>
<ul>
<li>当T为叶子结点时，其左右孩子均为空，则DescNum域为0</li>
<li>当T不为叶子节点时，但其只有一棵子树，则其DescNum域&gt;=1</li>
<li>当T不为叶子节点时，且有两棵子树，则其DescNum域&gt;=2</li>
</ul>
<p>我们将问题规模逐渐缩小</p>
<p>当T为叶子结点时，<strong>左右子树均为空，子孙数为0</strong>，当T不为叶子结点时，<strong>子孙数等于其左子树加其右子树</strong></p>
<p><strong>这样我们可以得出当T为空时，返回-1(叶子结点两孩子均为空)</strong></p>
<p><strong>其子孙数目=其左孩子数目+其右孩子数目+2</strong> 算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int DescNum(BinTree T) &#123;</span><br><span class="line">	if (!T) return -1;</span><br><span class="line">	int Des &#x3D; (DescNum(T-&gt;lchild) + DescNum(T-&gt;rchild)) + 2;&#x2F;&#x2F;精髓所在</span><br><span class="line">	T-&gt;DescNum &#x3D; Des;</span><br><span class="line">	return Des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>56、试写一算法，在先序后继线索二叉树中，查找给定结点 *p 在先序序列中的后继(假设二叉树的根节点未知)，并讨论实现此算法对存储结构有何要求？</p>
<p>思路：为了对得起这道题的难度，下列把先序线索化二叉树算法也一并给出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">TBitFindSucced</span><span class="params">(BinTree p)</span> </span>&#123;<span class="comment">//在线索二叉树中返回后继结点</span></span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ltag == List) <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreThreadtraversal</span><span class="params">(BinTree T)</span> </span>&#123;<span class="comment">//先序线索遍历二叉树</span></span><br><span class="line">	BinTree p;</span><br><span class="line">	p = T-&gt;lchild;</span><br><span class="line">	<span class="keyword">while</span> (p != T) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;ltag == List) &#123;</span><br><span class="line">			Visit(p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		Visit(p);</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">BinTree pre;</span><br><span class="line"><span class="function">Status <span class="title">Threading</span><span class="params">(BinTree* T)</span> </span>&#123;<span class="comment">//先序线索化二叉树</span></span><br><span class="line">	<span class="keyword">if</span> ((*T)) &#123;</span><br><span class="line">		(*T)-&gt;ltag = List;</span><br><span class="line">		(*T)-&gt;rtag = List;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(*T)-&gt;lchild) &#123;</span><br><span class="line">			(*T)-&gt;lchild = pre;</span><br><span class="line">			(*T)-&gt;ltag = Thread;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!pre-&gt;rchild) &#123;</span><br><span class="line">			pre-&gt;rchild = (*T);</span><br><span class="line">			pre-&gt;rtag = Thread;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = (*T);</span><br><span class="line">		<span class="keyword">if</span> ((*T)-&gt;ltag == List)</span><br><span class="line">			Threading(&amp;(*T)-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> ((*T)-&gt;rtag == List)</span><br><span class="line">			Threading(&amp;(*T)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">PreThreadBinTree</span><span class="params">(BinTree *T)</span> </span>&#123;<span class="comment">//先序线索化二叉树</span></span><br><span class="line">	BinTree Thrs = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));<span class="comment">//增加虚结点，统一情况</span></span><br><span class="line">	Thrs-&gt;ltag = List;</span><br><span class="line">	Thrs-&gt;lchild = (*T);</span><br><span class="line">	Thrs-&gt;rtag = Thread;</span><br><span class="line">	Thrs-&gt;rchild = Thrs;</span><br><span class="line">	pre = Thrs;</span><br><span class="line">	Threading(T);</span><br><span class="line">	pre-&gt;rchild = Thrs;</span><br><span class="line">	pre-&gt;rtag = Thread;</span><br><span class="line">	PreThreadtraversal(Thrs);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在存储结构中需要添加两个标志域，用于标志左右孩子指向的是孩子还是线索，如下图所示：</strong></li>
</ul>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210109021240576.png" alt="image-20210109021240576"></p>
<p>在之前学习过程中介绍过线索二叉树，传送门：</p>
<p>57、试写一算法，在后序后继线索二叉树中，查找给定结点，*p在后续后继线索二叉树中的后继(二叉树的根节点指针并未给出)并讨论实现算法对存储结构有何要求</p>
<p>思路：这道题做过线索二叉树后序遍历的话就很简单，只需要知道后序中如何查找后继就行，如下所示：</p>
<ul>
<li>若结点p是二叉树的根，则其后继为空</li>
<li>若结点<strong>p是其双亲的右孩子</strong><ul>
<li><strong>或是其双亲的左孩子</strong>，且其双亲<strong>没有</strong>右子树，则<strong>其后继为其双亲结点</strong></li>
</ul>
</li>
<li>若结点<strong>p是其双亲的左孩子</strong>，且其双亲<strong>有</strong>右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点**(如下图所示)**</li>
</ul>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210109032847991.png" alt="image-20210109032847991"></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">PostBitFindSucced</span><span class="params">(BinTree p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == Thread) <span class="keyword">return</span> p-&gt;rchild;<span class="comment">//p有后继线索</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;parent) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//p为根结点</span></span><br><span class="line">	<span class="keyword">if</span> (p == p-&gt;parent-&gt;rchild) <span class="keyword">return</span> p-&gt;parent;<span class="comment">//p为其双亲的右孩子</span></span><br><span class="line">	<span class="keyword">if</span> (p == p-&gt;parent-&gt;lchild &amp;&amp; p-&gt;parent-&gt;rtag == Thread)</span><br><span class="line">		<span class="keyword">return</span> p-&gt;parent;<span class="comment">//p为其双亲的左孩子且其双亲无右子树</span></span><br><span class="line">	BinTree q = p-&gt;parent-&gt;rchild;</span><br><span class="line">	<span class="keyword">while</span> (q-&gt;ltag == List || q-&gt;rtag == List) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;ltag == List)p = q = q-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span> q = q-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>58、试写一算法，再中序全线索二叉树的结点 p 之下，插入一棵以结点x为根，只有左子树的中序全线索二叉树，使x为根的二叉树称为p的左子树，如果p已存在左子树，则令其称为x的右子树，完成插入后的二叉树应保持全线索化</p>
<p>思路：这道题我们可以画图来看看线索的变化过程，找到变化过程后就很简单了，图示如下：</p>
<p>我们先来看当p为根的子树有左子树时的场景：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210110063417832.png" alt="image-20210110063417832"></p>
<p>依照题目要求，<strong>我们可以看到P是有左子树的，则我们需要将P的左子树称为 J 的右子树，同时让J称为P的左子树，我们先不改变线索走向，来看看连接后的逻辑图，如下所示：</strong></p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210110064026853.png" alt="image-20210110064026853"></p>
<p>从上分析可知，我们需要改变的只有一处，中序遍历顺序为：左 根 右：</p>
<ul>
<li>在P结点有左子树时候，我们只需要将X的右孩子与其连接，然后改变其中序遍历的第一个结点的前驱即可。</li>
</ul>
<p>而当 P 结点没有左子树时，我们只需要改变 X结点左子树 中序序列 最后一个序列所在结点的后继指针，让其指向P即可。</p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">xISp_Left</span><span class="params">(BinTree *p, BinTree *x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((*p)-&gt;rtag == Thread||!(*p)-&gt;lchild) &#123;<span class="comment">//p的左子树为线索，代表x可以成为其左子树，</span></span><br><span class="line">		(*p)-&gt;ltag = List;</span><br><span class="line">		(*p)-&gt;lchild = *x;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//改变x最后一结点的后继</span></span><br><span class="line">		BinTree q = (*x);</span><br><span class="line">		<span class="keyword">while</span> (q-&gt;rchild != (*x)) &#123;<span class="comment">//x只有左子树，其最后一个序列一定是根</span></span><br><span class="line">			<span class="keyword">while</span> (q-&gt;ltag = List) q = q-&gt;lchild;</span><br><span class="line">			<span class="keyword">while</span> (q-&gt;rchild != (*x) &amp;&amp; q-&gt;rtag == Thread) q = q-&gt;rchild;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != (*x)) q = q-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		q-&gt;rchild = (*p);<span class="comment">//改变后继</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		(*x)-&gt;rtag = List;</span><br><span class="line">		(*x)-&gt;rchild = (*p)-&gt;lchild;</span><br><span class="line">		(*p)-&gt;lchild = (*x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//改变其右子树中序遍历第一结点的前驱，需要指向 (*x)</span></span><br><span class="line"></span><br><span class="line">		BinTree q = (*x)-&gt;rchild;</span><br><span class="line">		<span class="keyword">while</span> (q-&gt;ltag == List) q = q-&gt;lchild;</span><br><span class="line">		q-&gt;lchild = (*x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试通过</strong></p>
<p>59、编写算法完成下列操作，无重复的输出以孩子兄弟链表存储的树T中所有的边，输出形式为(k1,k2),…(ki,kj),…,其中，k1和kj为树种的结点标识</p>
<p>思路：这是第一道关于一般树的算法题，思路其实很简单，其一个队列，将根结点加入队列中，然后以他的孩子为基准不断添加，迭代根结点与其孩子和孩子的兄弟结点输出即可，当队列为空时，即停止，如下图所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210110085219193.png" alt="image-20210110085219193"></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int data;</span></span><br><span class="line"><span class="comment">    struct TreeNode* child;</span></span><br><span class="line"><span class="comment">    struct TreeNode* brother;</span></span><br><span class="line"><span class="comment">&#125;*Tree;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Status CreateTree(Tree *T) &#123;</span></span><br><span class="line"><span class="comment">//约定，采用二叉树的先序序列创建一般树，左子树为其根的孩子，右子树为其根的兄弟</span></span><br><span class="line"><span class="comment">    char ch;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%c&quot;, &amp;ch);</span></span><br><span class="line"><span class="comment">    if (ch == &#x27;#&#x27;) *T = NULL;</span></span><br><span class="line"><span class="comment">    else &#123;</span></span><br><span class="line"><span class="comment">        (*T) = (Tree)malloc(sizeof(struct TreeNode));</span></span><br><span class="line"><span class="comment">        (*T)-&gt;data = ch;</span></span><br><span class="line"><span class="comment">        CreateTree(&amp;(*T)-&gt;child);</span></span><br><span class="line"><span class="comment">        CreateTree(&amp;(*T)-&gt;brother);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//打印所有边</span></span><br><span class="line"><span class="function">Status <span class="title">Print_RootChild</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    Tree p = T;</span><br><span class="line">    EnQueue(&amp;Q, p);</span><br><span class="line">    <span class="keyword">while</span> (Q.front != Q.rear) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;p);</span><br><span class="line">        Tree cd = p-&gt;child;</span><br><span class="line">        <span class="keyword">while</span> (cd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cd-&gt;child) EnQueue(&amp;Q, cd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%c,%c) &quot;</span>, p-&gt;data, cd-&gt;data);</span><br><span class="line">            cd = cd-&gt;brother;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210110094541646.png" alt="image-20210110094541646"></p>
<p>60、试编写算法，对一颗孩子兄弟链表表示的树统计叶子的个数</p>
<p>思路：遍历一遍树，当前结点没孩子的时候即计数变量加1，我们可以采用递归来实现，如下所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210110095929776.png" alt="image-20210110095929776"></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leafNumber</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;child)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tree cd = T-&gt;child; cd; cd = cd-&gt;brother) &#123;<span class="comment">//横向兄搜索</span></span><br><span class="line">        num += leafNumber(cd);<span class="comment">//递归纵向孩子搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的递归</p>
<p>61、试编写算法，求一棵以孩子兄弟链表表示的树的度</p>
<p>思路：和上道题一样可以使用递归求解，孩子的兄弟个数代表着这颗子树的度，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeMaxDegree</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;child) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> deg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tem = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tree p = T-&gt;child; p; p = p-&gt;brother, max++) &#123;</span><br><span class="line">        tem=TreeMaxDegree(p);</span><br><span class="line">        <span class="keyword">if</span> (deg &lt; tem) deg = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; deg) max = deg;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试图例：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210111021509034.png" alt="image-20210111021509034"></p>
<p>62、对以孩子兄弟链表表示的树编写计算树的深度的算法</p>
<p>思路：还是可以用递归求解，去比较子树的深度，然后求出最大值即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tree p = T; p; p = p-&gt;brother) &#123;</span><br><span class="line">        m = TreeDepth(p-&gt;child) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) n = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>63、对以孩子链表表示的树编写计算树的深度的算法</p>
<p>思路：这题我感觉考的是创建，至于深度和上题思路类同，我们采用指针数组为其分配孩子链的空间即可，完整代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct CTreeNode &#123;</span></span><br><span class="line"><span class="comment">    char data;</span></span><br><span class="line"><span class="comment">    int ChildNumber;</span></span><br><span class="line"><span class="comment">    struct CTreeNode** child;//靠ChildNumBer分配孩子个数，指针数组存储孩子域</span></span><br><span class="line"><span class="comment">&#125;*CTree;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//先序孩子链创建树</span></span><br><span class="line"><span class="comment">Status CreateCTree(CTree *T) &#123;</span></span><br><span class="line"><span class="comment">    if (!((*T) = (CTree)malloc(sizeof(struct CTreeNode)))) return ERROR;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%c,%d&quot;, &amp;(*T)-&gt;data, &amp;(*T)-&gt;ChildNumber);</span></span><br><span class="line"><span class="comment">    if((*T)-&gt;ChildNumber &lt; 0) return ERROR;</span></span><br><span class="line"><span class="comment">    if (!(*T)-&gt;ChildNumber) &#123;</span></span><br><span class="line"><span class="comment">        (*T)-&gt;child = NULL;</span></span><br><span class="line"><span class="comment">        return OK;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //按照孩子个数分配空间</span></span><br><span class="line"><span class="comment">    if (!((*T)-&gt;child = (CTree*)malloc(sizeof(CTree) * (*T)-&gt;ChildNumber))) return ERROR;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; (*T)-&gt;ChildNumber; i++)</span></span><br><span class="line"><span class="comment">        CreateCTree(&amp;(*T)-&gt;child[i]);</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//先序序列打印树</span></span><br><span class="line"><span class="comment">Status Print_CTree(CTree T) &#123;</span></span><br><span class="line"><span class="comment">    if (!T) return ERROR;</span></span><br><span class="line"><span class="comment">    printf(&quot;%c&quot;, T-&gt;data);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; T-&gt;ChildNumber; i++) &#123;</span></span><br><span class="line"><span class="comment">        Print_CTree(T-&gt;child[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CTreeDepth</span><span class="params">(CTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;ChildNumber) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T-&gt;ChildNumber; i++) &#123;</span><br><span class="line">        m = CTreeDepth(T-&gt;child[i]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) n = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试图例：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210111032527707.png" alt="image-20210111032527707"></p>
<p>64、对以双亲表表示的树编写计算树的深度的算法</p>
<p>思路：如下图所示的双亲表，我们可以从末尾开始不断寻找其双亲更新最大深度，同时优化时间避免重复双亲的查找即可</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210111040800678.png" alt="image-20210111040800678"></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define MAXPTREE_DATASIZE 255</span></span><br><span class="line"><span class="comment">typedef struct PTreeDataNode &#123;</span></span><br><span class="line"><span class="comment">    int parent;</span></span><br><span class="line"><span class="comment">    char data;</span></span><br><span class="line"><span class="comment">&#125;PTreeData;//双亲表数据域结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct PTreeNode &#123;//双亲表</span></span><br><span class="line"><span class="comment">    PTreeData PTB[MAXPTREE_DATASIZE];</span></span><br><span class="line"><span class="comment">    int len;</span></span><br><span class="line"><span class="comment">&#125;*PTree;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Status CreatePTree(PTree *PT) &#123;//创建一个双亲表</span></span><br><span class="line"><span class="comment">    if (!((*PT) = (PTree)malloc(sizeof(struct PTreeNode)))) return ERROR;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    scanf(&quot;%d&quot;, &amp;(*PT)-&gt;len);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= (*PT)-&gt;len; i++) &#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d,%c&quot;, &amp;(*PT)-&gt;PTB[i].parent, &amp;(*PT)-&gt;PTB[i].data);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        if ((*PT)-&gt;PTB[i].parent &lt; 0) return ERROR;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        if (i == 1) (*PT)-&gt;PTB[i].parent = 0;//根结点双亲为1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//打印此双亲表</span></span><br><span class="line"><span class="comment">Status Print_PTreeB(PTree PT) &#123;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= PT-&gt;len; i--)</span></span><br><span class="line"><span class="comment">        printf(&quot;%d,%c\n&quot;, PT-&gt;PTB[i].parent, PT-&gt;PTB[i].data);</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PTreeDepth</span><span class="params">(PTree PT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = PT-&gt;len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tem = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">1</span> &gt; <span class="number">0</span>) &amp;&amp; PT-&gt;PTB[i].parent == PT-&gt;PTB[i - <span class="number">1</span>].parent) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j = PT-&gt;PTB[j].parent, tem++);<span class="comment">//寻找根结点，tem计算此结点到根的高度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新最大高度</span></span><br><span class="line">        <span class="keyword">if</span> (dep &lt; tem) dep = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试通过：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210111044141943.png" alt="image-20210111044141943"></p>
<p>65、已知一棵二叉树的前序序列和中序序列分别存于两个一维数组中，试编写算法建立该二叉树的二叉链表。</p>
<p>思路：我们需要通过[先序序列]和[中序序列]唯一确定一棵二叉树，若只给出先序序列，或只给出中序序列，将会有多种可能的二叉树结构，如下所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210112032259166.png" alt="image-20210112032259166"></p>
<p>两棵不同的二叉树，其先序序列是一样的，而基于此先序序列能创建的二叉树还有很多</p>
<p>通过中序序列和先序序列，我们可以唯一确定一棵二叉树的原因在于：</p>
<ul>
<li><strong>先序序列的顺序为：根、左、右</strong>，可以确定根的位置，当前元素即为该子树的根</li>
<li><strong>中序序列的顺序为：左、根、右</strong>，可以看到，在根的左边为其左子树，在根的右边为其右子树</li>
</ul>
<p>则我们可以由在先序序列中的根去中序序列中确定其位置所在，<strong>并划分其左右子树所处的序列，来进行左右子树的连接</strong></p>
<p>此过程为一个递归的过程，详细如大佬在百度问答所述：</p>
<p>前序先访问根节点，遍历左序然后右序。中序先遍历左序然后访问根节点，遍历右序。</p>
<p>假设某二叉树的bai先序遍历序列是abdgcefh，中序遍历序列是dgbaechf，其逻辑结构如图：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210112033211206.png" alt="image-20210112033211206"></p>
<p>分析：先序遍历序列的第一个字符为根结点。对于中序遍历，根结点在中序遍历序列的中间，左边部分是根结点的左子树的中序遍历序列，右边部分是根结点的右子树的中序遍历序列。</p>
<ul>
<li>先序：abdgcefh –&gt; a bdg cefh</li>
<li>中序：dgbaechf –&gt; dgb a echf</li>
</ul>
<p><strong>左子树部分</strong></p>
<p>得出结论：a是树根，a有左子树和右子树，左子树有bdg结点，右子树有cefh结点。</p>
<ul>
<li>先序：bdg –&gt; b dg</li>
<li>中序：dgb –&gt; dg b</li>
</ul>
<p>得出结论：b是左子树的根结点，b无右子树，有左子树。</p>
<ul>
<li><p>先序：dg –&gt; d g</p>
</li>
<li><p>中序：dg –&gt; d g</p>
</li>
</ul>
<p><strong>右子树部分</strong></p>
<p>得出结论：d是b的左子树的根结点，d无左子树，有右子树。</p>
<ul>
<li><p>先序：cefh –&gt; c e fh</p>
</li>
<li><p>中序：echf –&gt; e c hf</p>
</li>
</ul>
<p>得出结论：c是右子树的根结点，c有左子树(只有e结点)，有右子树(有fh结点)。</p>
<ul>
<li><p>先序：fh –&gt; f h</p>
</li>
<li><p>中序：hf –&gt; h f</p>
</li>
</ul>
<p>得出结论：f是c的右子树的根结点，f有左子树(只有h结点)，无右子树。</p>
<p>根据上述，我们已经可以画出此二叉树的逻辑图，但是如何通过程序创建呢？<strong>我们采用分治</strong>的思想，如同二分搜素，划定左右边界</p>
<p><strong>当当前子树所在的先序序列或其中序序列左边界大于其右边界时，返回NULL，代表此位置已无子树</strong></p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210112035709735.png" alt="image-20210112035709735"></p>
<p>中序序列确定在先序序列中所在根的左右子树，分治进行其左右子树的创建，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BinTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//char Pre_ch[] = &quot;abdgcefh&quot;;//先序序列</span></span><br><span class="line"><span class="comment">//char In_ch[] = &quot;dgbaechf&quot;;//中序序列</span></span><br><span class="line"><span class="function">BinTree <span class="title">Pre_In_OrderCreateBinTree</span><span class="params">(<span class="keyword">char</span>* Pre_ch, <span class="keyword">char</span>* In_ch, <span class="keyword">int</span> Pre_Start, <span class="keyword">int</span> Pre_End, <span class="keyword">int</span> In_Start, <span class="keyword">int</span> In_End)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (In_Start &gt; In_End || Pre_Start &gt; Pre_End)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//返回空</span></span><br><span class="line">	BinTree p = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">	p-&gt;data = Pre_ch[Pre_Start];</span><br><span class="line">	<span class="keyword">int</span> i = In_Start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在中序序列中需寻找 当前 根 结点 所在位置，并且划定左右边界</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; In_End) &#123;</span><br><span class="line">		<span class="keyword">if</span> (In_ch[i] == Pre_ch[Pre_Start]) <span class="keyword">break</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分治</span></span><br><span class="line">	BinTree Lroot = Pre_In_OrderCreateBinTree(Pre_ch, In_ch, Pre_Start + <span class="number">1</span>, Pre_Start + (i - In_Start), In_Start, i - <span class="number">1</span>);</span><br><span class="line">	p-&gt;lchild = Lroot;</span><br><span class="line">	BinTree Rroot = Pre_In_OrderCreateBinTree(Pre_ch, In_ch, Pre_Start + (i - In_Start) + <span class="number">1</span>, Pre_End, i + <span class="number">1</span>, In_End);</span><br><span class="line">	p-&gt;rchild = Rroot;</span><br><span class="line">	<span class="comment">//返回其根</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序序列创建法检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*char* Bit = (char*)malloc(sizeof(char) * ((2 * Tlen) + 2));</span></span><br><span class="line"><span class="comment">	int i = -1;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status PreOrder_Traversal(BinTree T,char *Bit,int* i) &#123;</span></span><br><span class="line"><span class="comment">	(*i)++;</span></span><br><span class="line"><span class="comment">	if (!T) &#123;</span></span><br><span class="line"><span class="comment">		Bit[*i] = &#x27;#&#x27;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else&#123;</span></span><br><span class="line"><span class="comment">		Bit[*i] = T-&gt;data;</span></span><br><span class="line"><span class="comment">		PreOrder_Traversal(T-&gt;lchild, Bit, i);</span></span><br><span class="line"><span class="comment">		PreOrder_Traversal(T-&gt;rchild, Bit, i);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	return OK;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">Status InOrder_Traversal(BinTree T) &#123;</span></span><br><span class="line"><span class="comment">	if (T) &#123;</span></span><br><span class="line"><span class="comment">		InOrder_Traversal(T-&gt;lchild);</span></span><br><span class="line"><span class="comment">		printf(&quot;%c&quot;, T-&gt;data);</span></span><br><span class="line"><span class="comment">		InOrder_Traversal(T-&gt;rchild);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//凹入法打印</span></span><br><span class="line"><span class="comment">Status Print_BinTree(BinTree T, int n) &#123;</span></span><br><span class="line"><span class="comment">	if (!T) return OK;</span></span><br><span class="line"><span class="comment">	Print_BinTree(T-&gt;rchild, n + 1);</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; n; i++) printf(&quot;\t&quot;);</span></span><br><span class="line"><span class="comment">	if (n &gt;= 0)</span></span><br><span class="line"><span class="comment">		printf(&quot;---%c\n&quot;, T-&gt;data);</span></span><br><span class="line"><span class="comment">	Print_BinTree(T-&gt;lchild, n + 1);</span></span><br><span class="line"><span class="comment">	return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>测试图例：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210112040119159.png" alt="image-20210112040119159"></p>
<p>66、假设有n个结点的树T采用了<strong>双亲</strong>表示法，写出由此建立树的孩子兄弟链表的算法</p>
<p>思路：这题我们依旧可以采用分治的思想，去创建其孩子和兄弟，有双亲表我们只需要知道：</p>
<ul>
<li>孩子是其双亲域与当前结点下标相同</li>
<li>双亲是其双亲域域当前结点的双亲域相同</li>
</ul>
<p>同时因为递归最后会返回，需要避免重复判断出现，我们需要在当前结点的孩子或兄弟为空(未被创建)的时候递归其孩子和兄弟，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define MAXPTREE_DATASIZE 255</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct PTreeDataNode &#123;</span></span><br><span class="line"><span class="comment">    int parent;</span></span><br><span class="line"><span class="comment">    char data;</span></span><br><span class="line"><span class="comment">&#125;PTreeData;//双亲表数据域结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct PTreeNode &#123;//双亲表</span></span><br><span class="line"><span class="comment">    PTreeData PTB[MAXPTREE_DATASIZE];</span></span><br><span class="line"><span class="comment">    int len;</span></span><br><span class="line"><span class="comment">&#125;*PTree;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int data;</span></span><br><span class="line"><span class="comment">    struct TreeNode* child;</span></span><br><span class="line"><span class="comment">    struct TreeNode* brother;</span></span><br><span class="line"><span class="comment">&#125;*Tree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PTreeCreateTree</span><span class="params">(PTree PT, Tree* T, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    (*T) = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    (*T)-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;data = PT-&gt;PTB[i].data;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">if</span> (PT-&gt;PTB[k].parent == i &amp;&amp; !(*T)-&gt;child)<span class="comment">//该结点的双亲域为当前结点，当前结点的孩子域未被访问</span></span><br><span class="line">            PTreeCreateTree(PT, &amp;(*T)-&gt;child, k, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span> (PT-&gt;PTB[j].parent == PT-&gt;PTB[i].parent &amp;&amp; !(*T)-&gt;brother)</span><br><span class="line">            PTreeCreateTree(PT, &amp;(*T)-&gt;brother, j, n);<span class="comment">//该结点的双亲域为当前结点的双亲域，当前结点的兄弟域未被访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>67、假设以二元组(F,C)的形式输入一棵树的诸边(其中 F 表示 双亲结点的标识，C表示孩子结点表示)，且在输入的二元组序列中，C是按层次顺序出现的，F=”-“时，C为结点表示，若C也为‘-’,则表示输入结束。例如，如下所示树的输入序列为：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210113023421177.png" alt="image-20210113023421177"></p>
<p>思路：这题与之前那道二叉树的题类同，看到C按层次顺序出现时，我们可以想到，当前F若不为-，则肯定与已扫描过的C相同，则我们可以采用队列的方式先迭代孩子，再迭代与其F相同的兄弟，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*#define TWOTUPMAXSIZE 255</span></span><br><span class="line"><span class="comment">typedef struct TwotupNode &#123;</span></span><br><span class="line"><span class="comment">    char F;</span></span><br><span class="line"><span class="comment">    char C;</span></span><br><span class="line"><span class="comment">&#125;Twotup[TWOTUPMAXSIZE];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Status CreateTwotup(Twotup *Tt) &#123;//创建二元组</span></span><br><span class="line"><span class="comment">    char tem;</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (TRUE) &#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%c%c%c&quot;, &amp;(*Tt)[i].F, &amp;(*Tt)[i].C, &amp;tem);</span></span><br><span class="line"><span class="comment">        if ((*Tt)[i].C == &#x27;-&#x27;) break;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Status Print_Ttup(Twotup Tt) &#123;//check二元组</span></span><br><span class="line"><span class="comment">    int i = -1;</span></span><br><span class="line"><span class="comment">    do &#123;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        printf(&quot;%c,%c\n&quot;, Tt[i].F, Tt[i].C);</span></span><br><span class="line"><span class="comment">    &#125; while (Tt[i].C != &#x27;-&#x27;);</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">TtCreateTree</span><span class="params">(Twotup Tt, Tree* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tt[<span class="number">0</span>].F != <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> ERROR;<span class="comment">//序列错误</span></span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    (*T) = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    (*T)-&gt;child = (*T)-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;data = Tt[<span class="number">0</span>].C;</span><br><span class="line">    Tree p = (*T);</span><br><span class="line">    EnQueue(&amp;Q, p);<span class="comment">//根结点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Tt[i].C != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;p);<span class="comment">//取出其双亲所在的二元组元素</span></span><br><span class="line">        <span class="keyword">char</span> tem = p-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (Tt[i].F == tem) &#123;</span><br><span class="line">            p-&gt;child = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));<span class="comment">//迭代其孩子</span></span><br><span class="line">            p = p-&gt;child;</span><br><span class="line">            p-&gt;data = Tt[i].C;</span><br><span class="line">            p-&gt;child = p-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">            EnQueue(&amp;Q, p);<span class="comment">//入队</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (Tt[i].C != <span class="string">&#x27;-&#x27;</span> &amp;&amp; Tt[i].F == tem) &#123;<span class="comment">//迭代其兄弟</span></span><br><span class="line">                p-&gt;brother = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">                p = p-&gt;brother;</span><br><span class="line">                p-&gt;data = Tt[i].C;</span><br><span class="line">                p-&gt;child = p-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">                EnQueue(&amp;Q, p);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ERROR;<span class="comment">//未按层次输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>68、已知一棵树的由根至叶子结点按层次输入的结点序列及每个结点的度(每层中自左至右输入)，试写出构造此树的孩子兄弟链表的算法</p>
<p>思路：首先约定输入序列为(结点元素，度)，若度为-1时，输入结束，若度为0，则该结点孩子域为空，若度不为0，则创建其孩子并循环创建其孩子的兄弟即可，同时需要将结点依次入队，需要注意的是添加的孩子与其在二元组中的对应，<strong>由于二元组是按层次序列输入的，则孩子的位置可以累加获得，而边界即为此时已创建结点子树的总个数</strong>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define EDMAXSIZE 255//二元组最大容量</span></span><br><span class="line"><span class="comment">typedef struct EDNode &#123;//二元组结构</span></span><br><span class="line"><span class="comment">    char Elem;</span></span><br><span class="line"><span class="comment">    int deg;</span></span><br><span class="line"><span class="comment">&#125;ED[EDMAXSIZE];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Status CreateED(ED* e) &#123;//创建二元组</span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (TRUE) &#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%c%d&quot;, &amp;(*e)[i].Elem, &amp;(*e)[i].deg);</span></span><br><span class="line"><span class="comment">        if ((*e)[i].deg == -1) break;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return OK;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">Elem_degCreateTree</span><span class="params">(Tree* T, ED ch)</span> </span>&#123;<span class="comment">//通过二元组创建其孩子兄弟链结构树</span></span><br><span class="line"><span class="comment">//约定输入为：元素——度</span></span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>].deg == <span class="number">-1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//无元素</span></span><br><span class="line"></span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    (*T) = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    (*T)-&gt;child = (*T)-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;data = ch[<span class="number">0</span>].Elem;<span class="comment">//创建root</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//当前结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//当前结点子树位置</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//当前结点子树总个数</span></span><br><span class="line">    Tree p = (*T);</span><br><span class="line">    EnQueue(&amp;Q, p);</span><br><span class="line">    <span class="keyword">while</span> (ch[i].deg != <span class="number">-1</span>) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;p);</span><br><span class="line">        k += ch[i].deg;<span class="comment">//累加子树个数</span></span><br><span class="line">        <span class="keyword">if</span> (ch[i].deg == <span class="number">0</span>) p-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;child = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            p-&gt;child-&gt;data = ch[++j].Elem;<span class="comment">//第一个孩子</span></span><br><span class="line">            p-&gt;child-&gt;child = p-&gt;child-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;child);</span><br><span class="line">            <span class="keyword">if</span> (ch[i].deg &gt; <span class="number">1</span>) &#123;<span class="comment">//若度大于1，则添加其兄弟</span></span><br><span class="line">                p = p-&gt;child;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                    p-&gt;brother = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">                    p-&gt;brother-&gt;child = p-&gt;brother-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">                    p-&gt;brother-&gt;data = ch[++j].Elem;</span><br><span class="line">                    EnQueue(&amp;Q, p-&gt;brother);</span><br><span class="line">                    p = p-&gt;brother;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试通过：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210113042724457.png" alt="image-20210113042724457"></p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210113042743315.png" alt="image-20210113042743315"></p>
<p>69、假设以二叉链表存储的二叉树中，每个结点所行数据元素均为单字母，试编写算法，按树状打印二叉树的算法，入下图所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210113043811346.png" alt="image-20210113043811346"></p>
<p>思路：对照上图，不难发现这是一个<strong>逆中序输出，而空格的个数即是其所在的层次，打印完元素后换行即可</strong>无需利用二维数组附加存储，说实话这道题我看了答案，我第一想到的就是二维数组然后确定其位置进行添加….算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Print_BinTree</span><span class="params">(BinTree T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) <span class="keyword">return</span> OK;</span><br><span class="line">	Print_BinTree(T-&gt;rchild, n + <span class="number">1</span>);<span class="comment">//递归其右子树</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);<span class="comment">//按层次打印空格</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---%c\n&quot;</span>, T-&gt;data);<span class="comment">//打印元素并换行</span></span><br><span class="line">	Print_BinTree(T-&gt;lchild, n + <span class="number">1</span>);<span class="comment">//递归其左子树</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>70、如果用大写字母表示二叉树结点，则一棵二叉树可以用符合下面语法图的字符序列表示，试写一个递归算法，由这种形式的字符序列，建立相应的二叉树的二叉链表存储结构。</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210114023247167.png" alt="image-20210114023247167"></p>
<p>思路：这题我又看了答案，之前的思路一直卡在如同建立广义表的思路上，想着如何分割字符串，但是却一直找不到其规律，后边看了答案后发现我思路完全错了，采用字符串长度去控制循环，然后递归实现其左右子树的创建，分为四种情况(在序列正确的情况下)</p>
<ul>
<li>若当前字符为‘#’,则代表当前树为空</li>
<li>若当前字符为’(‘,则代表进入其子树的创建，<strong>由于序列是根 左 右</strong> 【如A(B,C)其中A为根结点,B为左子树，C为右子树】 则子树的创建也是先序顺序</li>
<li>若当前字符为’)’或’,’ 则代表子树创建完毕，退出这层递归</li>
<li>其他字符则是代表根元素，创建根结点即可</li>
<li><strong>需要注意的是，当前状态取决于当前字符，所以每一种情况都需要将字符序列指针自增去判断下一状态</strong></li>
</ul>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lsorder为字符序列</span></span><br><span class="line"><span class="comment">//i为当前字符,初始情况下为0</span></span><br><span class="line"><span class="comment">//n为字符串总长度</span></span><br><span class="line"><span class="function">Status <span class="title">ListsCreateBinTree</span><span class="params">(BinTree* T, <span class="keyword">char</span>* lsorder, <span class="keyword">int</span> *i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*i &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//若为#，则为空树</span></span><br><span class="line">			(*T) = <span class="literal">NULL</span>;</span><br><span class="line">			(*i)++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//若当前为(，则代表传入其子树</span></span><br><span class="line">			(*i)++;</span><br><span class="line">			ListsCreateBinTree(&amp;(*T)-&gt;lchild, lsorder, i, n);</span><br><span class="line">			ListsCreateBinTree(&amp;(*T)-&gt;rchild, lsorder, i, n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;)&#x27;</span> || lsorder[*i] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//若为)或者,则代表子树递归结束，退出这成递归</span></span><br><span class="line">			(*i)++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//其他情况，建立根结点</span></span><br><span class="line">			(*T) = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BinTreeNode));</span><br><span class="line">			(*T)-&gt;data = lsorder[(*i)];</span><br><span class="line">			(*T)-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">			(*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">			(*i)++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>71、假设树上每个结点所含的数据元素为一个字母，并且以孩子-兄弟链表为树的存储结构，试写一个按凹入表方式打印一棵树的算法，如下如所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210114023606655.png" alt="image-20210114023606655"></p>
<p>思路，从上图可以得知，按行优先是先序序列(先孩子后兄弟)，有了69题的前车之鉴，这道题就是一道简单题，一样层次控制空格输出即可，<strong>需要注意的是，只有递归孩子的时候层次才会变化，而兄弟层次是不变的</strong>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Print_Tree</span><span class="params">(Tree T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, T-&gt;data);</span><br><span class="line">        Print_Tree(T-&gt;child, n + <span class="number">1</span>);</span><br><span class="line">        Print_Tree(T-&gt;brother, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>72、以孩子链表为树的存储结构，重做71题</p>
<p>思路：这题和上题思路类同，只不过孩子是通过节点中的”度变量”控制的，我们在递归其孩子的时候利用循环去递归其所有孩子即可，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Print_CTree</span><span class="params">(CTree T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, T-&gt;data);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T-&gt;ChildNumber; i++)</span><br><span class="line">                Print_CTree(T-&gt;child[i], n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>73、若用大写字母标识树的结点，则可用带标号的广义表形式表示一棵树，其语法图如下所示：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210114033511255.png" alt="image-20210114033511255"></p>
<p>例如71题中的树可用：A(B(E,F),C(G),D)表示</p>
<p>试写一递归算法，由这种广义表表示的字符序列构造树的孩子兄弟链表(提示：按照树和森林相互递归的定义写两个互相递归调用的算法，语法图中一对圆括号内的部分可看成为森林的语法图)</p>
<p>思路：把其转换成二叉树即可，采用70题的思路即可，略有不同的是，情况变为：</p>
<ul>
<li>若当前字符为’(‘，则代表创建其孩子</li>
<li>若当前字符为‘，’则代表创建其兄弟<ul>
<li><strong>需要注意的时，在兄弟创建结束后，需要退回上一层，因为序列是按【根 孩子 兄弟】则代表这棵子树已经创建完毕</strong></li>
</ul>
</li>
<li>若当前字符为‘)’，则代表子树创建完毕</li>
<li>为其他字符时，则创建根结点。</li>
</ul>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListsCreateTree</span><span class="params">(Tree* T, <span class="keyword">char</span>* lsorder, <span class="keyword">int</span>* i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//当前字符为左括号时，递归创建孩子</span></span><br><span class="line">            (*i)++;</span><br><span class="line">            ListsCreateTree(&amp;(*T)-&gt;child, lsorder, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//当前字符为右括号时，表示子树创建完毕，回到上一层</span></span><br><span class="line">            (*i)++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lsorder[*i] == <span class="string">&#x27;,&#x27;</span>) &#123;<span class="comment">//当前括号为逗号时，表示递归创建其兄弟</span></span><br><span class="line">            <span class="comment">//创建完后也许代表该子树创建完，需要回到上一层</span></span><br><span class="line">            (*i)++;</span><br><span class="line">            ListsCreateTree(&amp;(*T)-&gt;brother, lsorder, i, n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (*T) = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            (*T)-&gt;data = lsorder[*i];</span><br><span class="line">            (*T)-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">            (*T)-&gt;brother = <span class="literal">NULL</span>;</span><br><span class="line">            (*i)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过</p>
<p>74、试写义递归算法，以73题给定的树的广义表表示法的字符序列形式输出以孩子兄弟链表表示的树</p>
<p>思路：之前我们知道，序列是按先序给出的，则在进入子树时，添加左括号，进入兄弟时，添加逗号，结束一棵子树时(<strong>结束代表其没有孩子也没有兄弟，为叶结点的时候</strong>)，添加右括号即可，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PrintLists_Tree</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;child)<span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        PrintLists_Tree(T-&gt;child);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;brother) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            PrintLists_Tree(T-&gt;brother);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!T-&gt;child &amp;&amp; !T-&gt;brother)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>75、试写一递归算法，由73题定义的广义表表示法的字符序列，构造树的孩子链表</p>
<p>思路：这题依旧不难，采用73题的思路即可，还是用循环控制其孩子的输出，不同的是：为逗号或右括号时候<strong>需要返回两层，因为第一层作用于的是当前子树，而孩子链表需要返回其父结点才能进行其兄弟的构造</strong></p>
<p>算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*typedef struct CTreeNode &#123;</span></span><br><span class="line"><span class="comment">    char data;</span></span><br><span class="line"><span class="comment">    int ChildNumber;</span></span><br><span class="line"><span class="comment">    struct CTreeNode** child;//靠ChildNumBer分配孩子个数，指针数组存储孩子域</span></span><br><span class="line"><span class="comment">&#125;*CTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListsCreateCTree</span><span class="params">(CTree* T, <span class="keyword">char</span>* lsorder, <span class="keyword">int</span>* i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lsorder[(*i)] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            (*i)++;<span class="comment">//遇到左括号，则代表进入子树构建，字符递进</span></span><br><span class="line">            (*T)-&gt;ChildNumber++;<span class="comment">//子树空间递增</span></span><br><span class="line">            (*T)-&gt;child = (CTree*)<span class="built_in">realloc</span>((*T)-&gt;child, <span class="keyword">sizeof</span>(CTree) * (*T)-&gt;ChildNumber);<span class="comment">//为子树空间重新分配内存</span></span><br><span class="line">            <span class="comment">//因为逐步扩建子树空间只能是递增，所以不会出现数据丢失</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*T)-&gt;ChildNumber; j++) &#123;<span class="comment">//循环构造子树</span></span><br><span class="line">                (*T)-&gt;child = (CTree*)<span class="built_in">realloc</span>((*T)-&gt;child, <span class="keyword">sizeof</span>(CTree) * (*T)-&gt;ChildNumber);<span class="comment">//在递归内子树空间也许会递增，所以需要重新分配</span></span><br><span class="line">                ListsCreateCTree(&amp;(*T)-&gt;child[j], lsorder, i, n);<span class="comment">//构造子树</span></span><br><span class="line">                <span class="keyword">if</span> (lsorder[(*i)] == <span class="string">&#x27;,&#x27;</span>) &#123;<span class="comment">//返回后判断若是逗号，则代表还有兄弟，子树空间递增，字符递进</span></span><br><span class="line">                    (*T)-&gt;ChildNumber++;</span><br><span class="line">                    (*i)++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (lsorder[(*i)] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//返回后若是右括号，则代表子树构造完毕，返回上一层，同时字符递增</span></span><br><span class="line">                    (*i)++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lsorder[(*i)] == <span class="string">&#x27;,&#x27;</span> || lsorder[(*i)] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">           <span class="comment">//若当前字符是逗号或右括号，则代表当前子树没有子树，则返回上一层对其父节点进行操作</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (*T) = (CTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct CTreeNode));</span><br><span class="line">            (*T)-&gt;ChildNumber = <span class="number">0</span>;</span><br><span class="line">            (*T)-&gt;data = lsorder[(*i)];</span><br><span class="line">            (*T)-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">            (*i)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过：</p>
<p><img src="C:\Users\Axuan\AppData\Roaming\Typora\typora-user-images\image-20210115114909341.png" alt="image-20210115114909341"></p>
<p>76、试写一递归算法，以73题给定的树的广义表表示法的字符序列形式输出以孩子链表表示的树</p>
<p>思路：这题结合了74和75题的思路也很容易写出来，当我们碰到子树的时候则添加左括号，若子树数目大于0的时候，每一次的递归都添加逗号，当子树输出完后添加右括号，先序序列递归即可，算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*typedef struct CTreeNode &#123;</span></span><br><span class="line"><span class="comment">    char data;</span></span><br><span class="line"><span class="comment">    int ChildNumber;</span></span><br><span class="line"><span class="comment">    struct CTreeNode** child;//靠ChildNumBer分配孩子个数，指针数组存储孩子域</span></span><br><span class="line"><span class="comment">&#125;*CTree;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">PrintLists_CTree</span><span class="params">(CTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ChildNumber &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T-&gt;ChildNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            PrintLists_CTree(T-&gt;child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ChildNumber &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%A3%B5%E6%A0%91%E8%BE%B9%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%BA-lt-I-M-gt-lt-I-N-gt-lt-E-I-gt-lt-B-E-gt-lt-B-D-gt-lt-A-B-gt-lt-G-J-gt-lt-G-K-gt-lt-C-G-gt-lt-C-F-gt-lt-H-L-gt-lt-C-H-gt-lt-A-C-gt-%EF%BC%8C%E8%AF%B7%E7%94%BB%E5%87%BA%E8%BF%99%E6%A3%B5%E6%A0%91%EF%BC%8C%E5%B9%B6%E5%9B%9E%E7%AD%94%E4%B8%8B%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">1、已知一棵树边的结合为{&lt;I,M&gt;,&lt;I,N&gt;,&lt;E,I&gt;,&lt;B,E&gt;,&lt;B,D&gt;,&lt;A,B&gt;,&lt;G,J&gt;,&lt;G,K&gt;,&lt;C,G&gt;,&lt;C,F&gt;,&lt;H,L&gt;,&lt;C,H&gt;,&lt;A,C&gt;}，请画出这棵树，并回答下列问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E6%A3%B5%E5%BA%A6%E4%B8%BA2%E7%9A%84%E6%A0%91%E5%92%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">2、一棵度为2的树和一棵二叉树有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%B8%80%E6%A3%B5%E6%B7%B1%E5%BA%A6%E4%B8%BAH%E7%9A%84%E6%BB%A1k%E5%8F%89%E6%A0%91%E6%9C%89%E5%A6%82%E4%B8%8B%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">4、一棵深度为H的满k叉树有如下性质：</span></a>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2021/01/15/BinTree/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2021/01/15/BinTree/&text=BinTree"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2021/01/15/BinTree/&is_video=false&description=BinTree"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=BinTree&body=Check out this article: http://example.com/2021/01/15/BinTree/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2021/01/15/BinTree/&title=BinTree"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2021/01/15/BinTree/&name=BinTree&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2021/01/15/BinTree/&t=BinTree"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    John Doe
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>